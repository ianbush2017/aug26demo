<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Mini Doom-style Raycaster</title>
<style>
  html,body {height:100%; margin:0; background:#000;}
  canvas {display:block; margin:0 auto; background:#444;}
  .hud {
    position:fixed; left:12px; top:12px; color:#fff; font-family:monospace;
    background:rgba(0,0,0,0.3); padding:8px 10px; border-radius:8px;
  }
  .controls {position:fixed; right:12px; top:12px; color:#fff; font-family:monospace; background:rgba(0,0,0,0.3); padding:8px;border-radius:8px;}
</style>
</head>
<body>
<canvas id="c" width="900" height="500"></canvas>
<div class="hud" id="hud">HP: 100 &nbsp; Ammo: ‚àû &nbsp; Score: 0</div>
<div class="controls">
  Controls:<br>
  W/A/S/D, ‚Üë/‚Üì = move, ‚Üê/‚Üí = turn<br>
  SPACE = shoot, R = respawn
</div>

<script>
/* --- Mini raycaster FPS (classic Doom-ish) ---
   - Single HTML file
   - Simple grid map
   - Enemies are emoji sprites that approach player
   - Shooting uses a short-range hit test on aim direction
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const w = canvas.width, h = canvas.height;
const hud = document.getElementById('hud');

const map = [
  "##########",
  "#........#",
  "#..##....#",
  "#..##.E..#",
  "#........#",
  "#...E....#",
  "#........#",
  "#....##..#",
  "#........#",
  "##########"
];
// # wall, . floor, E enemy spawn

const TILE = 64;
const MAPW = map[0].length, MAPH = map.length;
const FOV = Math.PI/3;
const NUM_RAYS = 180; // vertical slices
const MAX_RENDER_DIST = 800;

let player = { x: TILE*1.8, y: TILE*1.8, ang: 0, speed: 0, hp:100, score:0 };
let keys = {};
let bullets = [];
let enemies = [];

function spawnEnemiesFromMap(){
  enemies = [];
  for(let y=0;y<MAPH;y++){
    for(let x=0;x<MAPW;x++){
      if(map[y][x]==='E'){
        enemies.push({
          x: (x+0.5)*TILE,
          y: (y+0.5)*TILE,
          hp: 20,
          lastHit: 0
        });
      }
    }
  }
}

// helpers
function isWall(px,py){
  const mx = Math.floor(px / TILE);
  const my = Math.floor(py / TILE);
  if(mx<0||my<0||mx>=MAPW||my>=MAPH) return true;
  return map[my][mx] === '#';
}

function clamp(a,min,max){ return Math.max(min, Math.min(max, a)); }

function castRays(){
  const strips = [];
  for(let i=0;i<NUM_RAYS;i++){
    const rayScreenPos = (-NUM_RAYS/2 + i) / (NUM_RAYS/2);
    const rayAng = player.ang + rayScreenPos * (FOV/2) * 2;
    // DDA
    let dist = 0;
    let hit = false;
    const step = 4;
    while(!hit && dist < MAX_RENDER_DIST){
      dist += step;
      const rx = player.x + Math.cos(rayAng) * dist;
      const ry = player.y + Math.sin(rayAng) * dist;
      if(isWall(rx,ry)){
        hit = true;
      }
    }
    strips.push({ dist: dist, ang: rayAng });
  }
  return strips;
}

// draw 3D view using vertical strip projection
function render3D(strips){
  ctx.clearRect(0,0,w,h);
  // sky
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(0,0,w,h/2);
  // floor
  ctx.fillStyle = '#444';
  ctx.fillRect(0,h/2,w,h/2);

  const stripWidth = w/NUM_RAYS;
  for(let i=0;i<strips.length;i++){
    let d = strips[i].dist;
    // simple fish-eye correction
    const angDiff = (strips[i].ang - player.ang);
    d *= Math.cos(angDiff);
    const height = clamp((TILE*800)/d, 0, h*2);
    const x = i*stripWidth;
    // shade by distance
    const shade = clamp(255 - d*0.25, 30, 255)|0;
    const color = `rgb(${shade}, ${shade/1.3|0}, ${shade/1.8|0})`;
    ctx.fillStyle = color;
    ctx.fillRect(x, (h/2) - height/2, stripWidth+1, height);
  }
}

// draw HUD/minimap/enemies as sprites
function renderSprites(strips){
  // draw simple sprites (enemies) as scaled emoji in view
  for(let e of enemies){
    if(e.hp<=0) continue;
    const dx = e.x - player.x, dy = e.y - player.y;
    const dist = Math.hypot(dx,dy);
    const angleTo = Math.atan2(dy,dx);
    let rel = angleTo - player.ang;
    // normalize angle -PI..PI
    while(rel<-Math.PI) rel += Math.PI*2;
    while(rel>Math.PI) rel -= Math.PI*2;
    // if inside FOV
    if(Math.abs(rel) < FOV/2 && dist < MAX_RENDER_DIST){
      // compute screen x using projection similar to rays
      const screenPos = (rel / (FOV/2)) * (w/2);
      const size = clamp((TILE*100)/dist, 12, 180);
      ctx.font = `${size}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // simple occlusion test: sample corresponding ray dist
      const rayIndex = Math.floor((rel/(FOV/2)) * (NUM_RAYS/2) + NUM_RAYS/2);
      const rayDist = strips[clamp(rayIndex,0,NUM_RAYS-1)].dist;
      if(dist < rayDist - 10){ // not occluded by wall
        ctx.fillText('üëπ', w/2 + screenPos, h/2, size);
        // draw small health bar
        const barW = 50;
        const barX = w/2 + screenPos - barW/2;
        const barY = h/2 + size/1.6;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(barX-1,barY-3,barW+2,8);
        ctx.fillStyle = 'red';
        ctx.fillRect(barX,barY, barW*(e.hp/20), 4);
      }
    }
  }

  // crosshair
  ctx.strokeStyle='rgba(255,255,255,0.9)';
  ctx.beginPath();
  ctx.moveTo(w/2-10,h/2);
  ctx.lineTo(w/2+10,h/2);
  ctx.moveTo(w/2,h/2-10);
  ctx.lineTo(w/2,h/2+10);
  ctx.stroke();
}

// simple world update: enemy AI moves toward player if visible
function updateWorld(dt){
  // move enemies toward player if path not blocked (basic)
  for(let e of enemies){
    if(e.hp<=0) continue;
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx,dy);
    const nx = dx/dist, ny = dy/dist;
    // attempt to step toward player with collision avoidance
    const speed = 30; // px/sec
    const step = speed * dt;
    const nextX = e.x + nx * step;
    const nextY = e.y + ny * step;
    if(!isWall(nextX,nextY) && dist>40){
      e.x = nextX; e.y = nextY;
    } else if(dist <= 40){
      // damage player on contact, cooldown per enemy
      const now = performance.now();
      if(!e.lastHit || now - e.lastHit > 800){
        e.lastHit = now;
        player.hp -= 8;
        if(player.hp<0) player.hp=0;
      }
    }
  }
}

// simple movement & collision for player
function movePlayer(dt){
  const walkSpeed = 120; // px/sec
  const strafeSpeed = 90;
  let vx=0, vy=0;
  if(keys['w']||keys['ArrowUp']) { vx += Math.cos(player.ang)*walkSpeed; vy += Math.sin(player.ang)*walkSpeed; }
  if(keys['s']||keys['ArrowDown']) { vx -= Math.cos(player.ang)*walkSpeed; vy -= Math.sin(player.ang)*walkSpeed; }
  if(keys['a']) { vx += Math.cos(player.ang - Math.PI/2)*strafeSpeed; vy += Math.sin(player.ang - Math.PI/2)*strafeSpeed; }
  if(keys['d']) { vx += Math.cos(player.ang + Math.PI/2)*strafeSpeed; vy += Math.sin(player.ang + Math.PI/2)*strafeSpeed; }
  // turn
  if(keys['ArrowLeft']) player.ang -= 2 * dt;
  if(keys['ArrowRight']) player.ang += 2 * dt;

  const nx = player.x + vx*dt;
  const ny = player.y + vy*dt;
  if(!isWall(nx, player.y)) player.x = nx;
  if(!isWall(player.x, ny)) player.y = ny;
}

// shooting: check the nearest enemy roughly centered in FOV and within range
function shoot(){
  // ray from player center
  // find enemy with smallest abs(angle difference) and visible and within 400px
  let best = null, bestScore = 1e9;
  for(let e of enemies){
    if(e.hp<=0) continue;
    const dx = e.x - player.x, dy = e.y - player.y;
    const dist = Math.hypot(dx,dy);
    const ang = Math.atan2(dy,dx);
    let rel = ang - player.ang;
    while(rel<-Math.PI) rel += 2*Math.PI;
    while(rel>Math.PI) rel -= 2*Math.PI;
    if(Math.abs(rel) < 0.18 && dist < 600){
      // line-of-sight test simple: sample along line until wall
      let blocked = false;
      const steps = Math.floor(dist/8);
      for(let s=1;s<steps;s++){
        const sx = player.x + Math.cos(ang)*s*8;
        const sy = player.y + Math.sin(ang)*s*8;
        if(isWall(sx,sy)){ blocked = true; break; }
      }
      if(!blocked){
        const score = Math.abs(rel) + dist/800;
        if(score < bestScore){ bestScore = score; best = e; }
      }
    }
  }
  if(best){
    // hit
    best.hp -= 12;
    player.score += 10;
    if(best.hp <= 0){
      player.score += 30;
    }
  } else {
    // miss or hit wall: short-range hit test on walls (optional visual)
  }
}

// initialization
spawnEnemiesFromMap();

// input
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if(e.key === ' ') { e.preventDefault(); shoot(); }
  if(e.key === 'r' || e.key === 'R'){ respawn(); }
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

// main loop
let last = performance.now();
function loop(now){
  const dt = (now - last)/1000;
  last = now;

  // handle movement
  movePlayer(dt);
  updateWorld(dt);

  // cast rays and render
  const strips = castRays();
  render3D(strips);
  renderSprites(strips);

  // update HUD
  hud.innerHTML = `HP: ${player.hp} &nbsp; Ammo: ‚àû &nbsp; Score: ${player.score}`;

  // enemy cleanup and respawn if killed
  for(let i=enemies.length-1;i>=0;i--){
    if(enemies[i].hp<=0){
      enemies.splice(i,1);
    }
  }
  // simple win/respawn condition: if no enemies, respawn some after delay
  if(enemies.length===0){
    // small break then repopulate
    setTimeout(()=>{ if(enemies.length===0) spawnEnemiesFromMap(); }, 600);
  }

  // death condition
  if(player.hp > 0){
    requestAnimationFrame(loop);
  } else {
    // render a red overlay and stop loop
    ctx.fillStyle = 'rgba(100,0,0,0.5)';
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle='white';
    ctx.font='40px monospace';
    ctx.textAlign='center';
    ctx.fillText('YOU DIED ‚Äî Press R to Respawn', w/2, h/2);
  }
}
requestAnimationFrame(loop);

function respawn(){
  player.hp = 100;
  player.x = TILE*1.8;
  player.y = TILE*1.8;
  player.ang = 0;
  player.score = 0;
  spawnEnemiesFromMap();
  last = performance.now();
  requestAnimationFrame(loop);
}

/* simple raycasting for walls (DDA-lite used above in castRays) */
function castRays(){
  const strips = [];
  for(let i=0;i<NUM_RAYS;i++){
    const rayScreenPos = (-NUM_RAYS/2 + i) / (NUM_RAYS/2);
    const rayAng = player.ang + rayScreenPos * (FOV/2) * 2;
    let dist = 0;
    const step = 6;
    let hit = false;
    while(!hit && dist < MAX_RENDER_DIST){
      dist += step;
      const rx = player.x + Math.cos(rayAng) * dist;
      const ry = player.y + Math.sin(rayAng) * dist;
      if(isWall(rx,ry)) hit = true;
    }
    strips.push({ dist, ang: rayAng });
  }
  return strips;
}
</script>
</body>
</html>
